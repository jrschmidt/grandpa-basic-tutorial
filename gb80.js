// Generated by CoffeeScript 1.9.2
var ActionController, BasicConsole, BoolExpBuilder, BooleanExpressionEvaluator, BooleanExpressionParser, ConsoleLineBuffer, InfoAndHelp, InterpreterHelpers, KeyHelper, KeyTalker, LineParser, NumExpBuilder, NumericExpressionEvaluator, NumericExpressionParser, NumericStringFormatter, NumericVariableRegister, ParseHelpers, ProgramController, ProgramLineBuilder, ProgramLineListing, StatementRunner, StrExpBuilder, StringExpressionConcatenator, StringExpressionParser, StringVariableRegister, SyntaxRules, UserInputHelper, VariableRegister, keyevent, keyup, monitor_amber, monitor_green, start,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

KeyTalker = (function() {
  function KeyTalker() {
    this.bconsole = new BasicConsole(this);
    this.keys = this.bconsole.keys;
    this.shift = "<no-shift>";
    this.key_mode = "<normal_mode>";
    this.controller = new ActionController(this);
    this.program_control = this.controller.program_control;
  }

  KeyTalker.prototype.get_mode = function() {
    return this.key_mode;
  };

  KeyTalker.prototype.reset_normal_mode = function() {
    return this.key_mode = "<normal_mode>";
  };

  KeyTalker.prototype.set_input_mode = function() {
    return this.key_mode = "<input_mode>";
  };

  KeyTalker.prototype.set_scroll_pause = function() {
    return this.key_mode = "<scroll_pause>";
  };

  KeyTalker.prototype.handle = function(key_code) {
    if (this.key_mode === "<input_mode>") {
      return this.handle_input(key_code);
    } else if (this.key_mode === "<scroll_pause>") {
      return this.resume_scroll();
    } else {
      return this.handle_normal(key_code);
    }
  };

  KeyTalker.prototype.handle_normal = function(key_code) {
    var line;
    if (key_code === 13) {
      line = this.bconsole.enter_line();
      return this.controller.handle_line_entry(line);
    } else if (key_code === 8) {
      return this.bconsole.backspace();
    } else if (key_code === 16) {
      return this.shift = "<shift>";
    } else {
      return this.bconsole.ch(this.keys.char(key_code, this.shift));
    }
  };

  KeyTalker.prototype.handle_input = function(key_code) {
    var line;
    if (key_code === 13) {
      line = this.bconsole.enter_line();
      this.program_control.handle_user_input(line);
      return this.program_control.restart_program();
    } else if (key_code === 8) {
      return this.bconsole.backspace();
    } else if (key_code === 16) {
      return this.shift = "<shift>";
    } else {
      return this.bconsole.ch(this.keys.char(key_code, this.shift));
    }
  };

  KeyTalker.prototype.resume_scroll = function() {
    this.key_mode = "<normal_mode>";
    return this.bconsole.resume_scroll();
  };

  KeyTalker.prototype.handle_keyup = function(key_code) {
    if (key_code === 16) {
      return this.shift = "<no-shift>";
    }
  };

  KeyTalker.prototype.monitor_amber = function() {
    return this.bconsole.monitor_amber();
  };

  KeyTalker.prototype.monitor_green = function() {
    return this.bconsole.monitor_green();
  };

  return KeyTalker;

})();

ActionController = (function() {
  function ActionController(key_talker) {
    this.keys = key_talker;
    this.bconsole = this.keys.bconsole;
    this.parser = new LineParser;
    this.formatter = new ProgramLineBuilder;
    this.line_listing = new ProgramLineListing;
    this.program_control = new ProgramController(this);
  }

  ActionController.prototype.handle_line_entry = function(string) {
    var line_object, lines;
    line_object = this.build_line_object(string);
    if (line_object.line_no) {
      return this.line_listing.add_or_change(line_object);
    } else {
      switch (line_object.command) {
        case "<list_command>":
          lines = this.line_listing.list();
          return this.bconsole.print_program(lines);
        case "<run_command>":
          return this.program_control.run_program();
        case "<clear_command>":
          return this.line_listing.clear();
        case "<info_command>":
          return this.bconsole.display_info("menu");
        default:
          return this.bconsole.error_message();
      }
    }
  };

  ActionController.prototype.build_line_object = function(string) {
    var parse_object;
    parse_object = this.parser.parse(string);
    if (parse_object === "<parse_error>") {
      return {
        command: "<parse_error>"
      };
    } else {
      return this.formatter.format(parse_object, string);
    }
  };

  return ActionController;

})();

ProgramController = (function() {
  function ProgramController(action_controller) {
    this.controller = action_controller;
    this.keys = this.controller.keys;
    this.bconsole = this.controller.bconsole;
    this.line_listing = this.controller.line_listing;
    this.statement_runner = new StatementRunner(this);
    this.input = this.statement_runner.input;
    this.lines = {};
    this.line_order = [];
    this.next_line_index = -1;
    this.next_line_no = 0;
    this.return_line_no = 0;
    this.return_line_index = 0;
    this.output = "";
    this.line_result = {};
  }

  ProgramController.prototype.run_program = function() {
    var line_objects, results;
    line_objects = this.line_listing.get_program_objects();
    this.load(line_objects);
    results = [];
    while (this.next_line_no > 0 && this.keys.get_mode() === "<normal_mode>") {
      results.push(this.run_next_line());
    }
    return results;
  };

  ProgramController.prototype.restart_program = function() {
    var results;
    this.keys.reset_normal_mode();
    results = [];
    while (this.next_line_no > 0 && this.keys.get_mode() === "<normal_mode>") {
      results.push(this.run_next_line());
    }
    return results;
  };

  ProgramController.prototype.load = function(lines) {
    this.lines = lines;
    this.line_order = this.sort_lines(lines);
    if (this.line_order.length > 0) {
      this.next_line_index = 0;
      return this.next_line_no = this.line_order[0];
    }
  };

  ProgramController.prototype.run_next_line = function() {
    var line_object;
    line_object = this.lines[this.next_line_no.toString()];
    this.line_result = this.statement_runner.run_command(line_object);
    if (this.line_result.hasOwnProperty("output")) {
      this.gb_output(this.line_result.output);
    }
    if (this.line_result.hasOwnProperty("sub")) {
      if (this.line_result.sub === "return") {
        this.next_line_no = this.return_line_no;
        this.next_line_index = this.return_line_index;
        this.return_line_no = 0;
        return this.return_line_index = 0;
      } else {
        if (this.line_result.sub === "yes") {
          this.update_next_line();
          this.return_line_no = this.next_line_no;
          this.return_line_index = this.next_line_index;
        }
        return this.reset_line_no(this.line_result.jump);
      }
    } else {
      return this.update_next_line();
    }
  };

  ProgramController.prototype.update_next_line = function() {
    this.next_line_index += 1;
    if (this.next_line_index < this.line_order.length) {
      return this.next_line_no = this.line_order[this.next_line_index];
    } else {
      return this.next_line_no = 0;
    }
  };

  ProgramController.prototype.reset_line_no = function(dest) {
    this.next_line_index = this.line_order.indexOf(dest);
    if (this.next_line_index < this.line_order.length) {
      return this.next_line_no = this.line_order[this.next_line_index];
    } else {
      return this.next_line_no = 0;
    }
  };

  ProgramController.prototype.gb_output = function(string) {
    if (string !== "") {
      this.output = string;
      return this.bconsole.println(string);
    }
  };

  ProgramController.prototype.handle_user_input = function(input_results) {
    return this.input.process_user_input(input_results);
  };

  ProgramController.prototype.sort_lines = function(lines) {
    var key, line, unsorted;
    unsorted = [];
    for (key in lines) {
      line = lines[key];
      unsorted.push(line.line_no);
    }
    return unsorted.sort(function(a, b) {
      return a - b;
    });
  };

  return ProgramController;

})();

StatementRunner = (function() {
  function StatementRunner(program_control) {
    this.program_control = program_control;
    this.keys = this.program_control.keys;
    this.helpers = new InterpreterHelpers(this);
    this.num_vars = this.helpers.num_vars;
    this.str_vars = this.helpers.str_vars;
    this.num_eval = this.helpers.num_eval;
    this.num_form = this.helpers.num_form;
    this.str_eval = this.helpers.str_eval;
    this.bx_eval = this.helpers.bx_eval;
    this.input = this.helpers.input;
  }

  StatementRunner.prototype.run_command = function(line_object) {
    switch (line_object.command) {
      case "<remark>":
        return this.line_result = {};
      case "<numeric_assignment>":
        return this.line_result = this.run_num_assign(line_object);
      case "<string_assignment>":
        return this.line_result = this.run_str_assign(line_object);
      case "<goto>":
        return this.line_result = this.run_goto(line_object);
      case "<gosub>":
        return this.line_result = this.run_gosub(line_object);
      case "<return>":
        return this.line_result = this.run_return(line_object);
      case "<if>":
        return this.line_result = this.run_if(line_object);
      case "<input_numeric>":
      case "<input_string>":
      case "<input_numeric_prompt>":
      case "<input_string_prompt>":
        return this.line_result = this.run_input(line_object);
      case "<print>":
        return this.line_result = this.run_print(line_object);
      case "<print_num>":
        return this.line_result = this.run_print_num(line_object);
      case "<end>":
        return this.line_result = this.run_end(line_object);
      default:
        return this.line_result = {};
    }
  };

  StatementRunner.prototype.run_num_assign = function(line_object) {
    this.num_vars.set(line_object.operand, this.num_eval.val(line_object.expression));
    return {};
  };

  StatementRunner.prototype.run_str_assign = function(line_object) {
    this.str_vars.set(line_object.operand, this.str_eval.val(line_object.expression));
    return {};
  };

  StatementRunner.prototype.run_goto = function(line_object) {
    var dest;
    dest = line_object.dest;
    return {
      jump: dest,
      sub: "no"
    };
  };

  StatementRunner.prototype.run_if = function(line_object) {
    var dest;
    dest = line_object.dest;
    if (this.bx_eval.val(line_object.cond)) {
      return {
        jump: dest,
        sub: "no"
      };
    } else {
      return {};
    }
  };

  StatementRunner.prototype.run_gosub = function(line_object) {
    var dest;
    dest = line_object.dest;
    return {
      jump: dest,
      sub: "yes"
    };
  };

  StatementRunner.prototype.run_return = function(line_object) {
    return {
      sub: "return"
    };
  };

  StatementRunner.prototype.run_input = function(line_object) {
    this.input.set_up_input(line_object);
    return {};
  };

  StatementRunner.prototype.run_print = function(line_object) {
    var string;
    string = this.str_eval.val(line_object.expression);
    return {
      output: string
    };
  };

  StatementRunner.prototype.run_print_num = function(line_object) {
    var number, string, var_name;
    var_name = line_object.name;
    number = this.num_eval.val({
      exp: "<var>",
      name: var_name
    });
    string = this.num_form.num_to_str(number);
    return {
      output: string
    };
  };

  StatementRunner.prototype.run_end = function(line_object) {
    return {
      jump: 0,
      sub: "no"
    };
  };

  return StatementRunner;

})();

SyntaxRules = (function() {
  function SyntaxRules() {
    this.keywords = ["CLEAR", "RUN", "INFO", "LIST", "REM", "GOTO", "GOSUB", "RETURN", "IF", "THEN", "INPUT", "PRINT", "PRINTLN", "CLEARSCRN", "TAB", "END", "RND"];
    this.keyword_tokens = ["<clear_command>", "<run_command>", "<info_command>", "<list_command>", "<remark>", "<goto>", "<gosub>", "<return>", "<if>", "<then>", "<input>", "<print>", "<print_line>", "<clear_screen>", "<tab>", "<end>", "<random>"];
    this.char_tokens = ["<sp>", "<equals>", "<semicolon>", "<comma>"];
    this.chars = " =;,";
    this.action_tokens = ["<line_number>", "<line_number_statement>", "<input_statement>", "<number_variable>", "<string_variable>", "<numeric_expression>", "<string_expression>", "<boolean_expression>", "<string>", "<characters>", "<integer>"];
    this.rules = [["CLEAR"], ["RUN"], ["INFO"], ["LIST"], ["<line_number>", "<sp>", "<line_number_statement>"], ["<line_number>"]];
    this.line_number_rules = [["REM", "<sp>", "<characters>"], ["REM"], ["<number_variable>", "<equals>", "<numeric_expression>"], ["<string_variable>", "<equals>", "<string_expression>"], ["GOTO", "<sp>", "<line_number>"], ["GOSUB", "<sp>", "<line_number>"], ["RETURN"], ["IF", "<sp>", "<boolean_expression>", "<sp>", "THEN", "<sp>", "<line_number>"], ["INPUT", "<sp>", "<input_statement>"], ["PRINT", "<sp>", "<number_variable>"], ["PRINT", "<sp>", "<string_expression>"], ["END"]];
    this.input_statement_rules = [["<number_variable>"], ["<string_variable>"], ["<string>", "<semicolon>", "<number_variable>"], ["<string>", "<semicolon>", "<string_variable>"]];
  }

  return SyntaxRules;

})();

LineParser = (function() {
  function LineParser() {
    this.helpers = new ParseHelpers;
    this.syntax = this.helpers.syntax;
    this.rules = this.syntax.rules;
    this.ln_rules = this.syntax.line_number_rules;
    this.input_rules = this.syntax.input_statement_rules;
  }

  LineParser.prototype.parse = function(string) {
    var j, len1, match, ref, result, rule;
    match = "no";
    ref = this.rules;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      rule = ref[j];
      if (match === "no") {
        result = this.look_for(string, rule);
        match = result.match;
      }
    }
    if (match === "yes") {
      if (result.remainder.length > 0) {
        result.parse_object = "<parse_error>";
      }
      return result.parse_object;
    } else {
      return "<parse_error>";
    }
  };

  LineParser.prototype.look_for = function(string, rule) {
    var cat, j, k, len1, len2, parse_object, ref, result, rule_match, tk, token, token_result;
    parse_object = [];
    rule_match = "unknown";
    for (j = 0, len1 = rule.length; j < len1; j++) {
      token = rule[j];
      if (rule_match !== "no") {
        cat = "none";
        if (indexOf.call(this.syntax.keywords, token) >= 0) {
          cat = "keyword";
        }
        if (indexOf.call(this.syntax.char_tokens, token) >= 0) {
          cat = "char";
        }
        if (indexOf.call(this.syntax.action_tokens, token) >= 0) {
          cat = "action";
        }
        switch (cat) {
          case "keyword":
            token_result = this.look_for_keyword(token, string);
            break;
          case "char":
            token_result = this.look_for_char(token, string);
            break;
          case "action":
            token_result = this.look_for_action(token, string);
            break;
          default:
            token_result = {
              match: "no"
            };
        }
        if (token_result.match === "yes") {
          ref = token_result.parse_object;
          for (k = 0, len2 = ref.length; k < len2; k++) {
            tk = ref[k];
            parse_object.push(tk);
          }
          if (string) {
            string = token_result.remainder;
          } else {
            string = "";
          }
        } else {
          rule_match = "no";
        }
      }
    }
    if (rule_match === "no") {
      result = {
        match: "no",
        remainder: ""
      };
    } else {
      result = {
        match: "yes",
        parse_object: parse_object
      };
      if (string) {
        result.remainder = string;
      } else {
        result.remainder = "";
      }
    }
    return result;
  };

  LineParser.prototype.look_for_keyword = function(token, string) {
    var find, i, result;
    find = string.indexOf(token);
    if (find === 0) {
      i = this.syntax.keywords.indexOf(token);
      result = {
        match: "yes",
        parse_object: [this.syntax.keyword_tokens[i]],
        remainder: string.slice(token.length)
      };
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  LineParser.prototype.look_for_char = function(token, string) {
    var ch, i, result;
    i = this.syntax.char_tokens.indexOf(token);
    ch = string[0];
    if (ch === this.syntax.chars[i]) {
      result = {
        match: "yes",
        parse_object: [token],
        remainder: string.slice(1)
      };
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  LineParser.prototype.look_for_action = function(token, string) {
    var result;
    switch (token) {
      case "<line_number>":
        result = this.helpers.look_for_line_number(string);
        break;
      case "<line_number_statement>":
        result = this.look_for_line_number_statement(string);
        break;
      case "<input_statement>":
        result = this.look_for_input_parameters(string);
        break;
      case "<number_variable>":
        result = this.helpers.look_for_numeric_identifier(string);
        break;
      case "<string_variable>":
        result = this.helpers.look_for_string_identifier(string);
        break;
      case "<numeric_expression>":
        result = this.helpers.num_exp_parser.numeric_parse(string);
        break;
      case "<string_expression>":
        result = this.helpers.str_exp_parser.string_value_parse(string);
        break;
      case "<boolean_expression>":
        result = this.helpers.bool_exp_parser.boolean_parse(string);
        break;
      case "<string>":
        result = this.helpers.look_for_string(string);
        break;
      case "<characters>":
        result = this.helpers.look_for_characters(string);
        break;
      case "<integer>":
        result = this.helpers.look_for_integer(string);
        break;
      default:
        result = {
          match: "no"
        };
    }
    return result;
  };

  LineParser.prototype.look_for_line_number_statement = function(string) {
    var j, len1, match, ref, result, rule;
    match = "no";
    ref = this.ln_rules;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      rule = ref[j];
      if (match === "no") {
        result = this.look_for(string, rule);
        match = result.match;
      }
    }
    if (match === "yes") {
      return result;
    } else {
      return {
        match: "no"
      };
    }
  };

  LineParser.prototype.look_for_input_parameters = function(string) {
    var j, len1, match, ref, result, rule;
    match = "no";
    ref = this.input_rules;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      rule = ref[j];
      if (match === "no") {
        result = this.look_for(string, rule);
        match = result.match;
      }
    }
    if (match === "yes") {
      return result;
    } else {
      return {
        match: "no"
      };
    }
  };

  return LineParser;

})();

ParseHelpers = (function() {
  function ParseHelpers() {
    this.syntax = new SyntaxRules;
    this.rules = this.syntax.rules;
    this.num_exp_parser = new NumericExpressionParser;
    this.str_exp_parser = new StringExpressionParser;
    this.bool_exp_parser = new BooleanExpressionParser(this);
  }

  ParseHelpers.prototype.look_for_line_number = function(string) {
    var n, result;
    result = {};
    n = parseInt(string);
    if (n > 0) {
      result.match = "yes";
      result.parse_object = ["<line_number>", n];
      result.remainder = string.slice(String(n).length);
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  ParseHelpers.prototype.look_for_numeric_identifier = function(string) {
    var id, len, ref, ref1, ref2, result;
    result = {};
    if (ref = string[0], indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", ref) >= 0) {
      if (ref1 = string[1], indexOf.call("0123456789", ref1) >= 0) {
        len = 2;
      } else {
        len = 1;
      }
      if ((len === string.length) || (ref2 = string[len], indexOf.call("=+-*/^)", ref2) >= 0)) {
        result.match = "yes";
        id = string.slice(0, len);
        result.parse_object = ["<number_variable>", id];
        result.remainder = string.slice(len);
      } else {
        result = {
          match: "no"
        };
      }
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  ParseHelpers.prototype.look_for_string_identifier = function(string) {
    var id, len, ref, ref1, ref2, result;
    result = {};
    if (string[0] === "$") {
      if (ref = string[1], indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", ref) >= 0) {
        if (ref1 = string[2], indexOf.call("0123456789", ref1) >= 0) {
          len = 2;
        } else {
          len = 1;
        }
      }
      if ((len === string.length - 1) || (ref2 = string[len + 1], indexOf.call("=+", ref2) >= 0)) {
        result.match = "yes";
        id = string.slice(1, len + 1);
        result.parse_object = ["<string_variable>", id];
        result.remainder = string.slice(len + 1);
      } else {
        result = {
          match: "no"
        };
      }
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  ParseHelpers.prototype.look_for_characters = function(string) {
    var result;
    result = {
      match: "yes",
      parse_object: ["<characters>", string],
      remainder: ""
    };
    return result;
  };

  ParseHelpers.prototype.look_for_string = function(string) {
    var ch, contents, cut, quote_check, remdr, result;
    quote_check = (function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = string.length; j < len1; j++) {
        ch = string[j];
        if (ch === '"') {
          results.push(ch);
        }
      }
      return results;
    })();
    if (quote_check.length >= 2 && string[0] === '"' && string.length > 2) {
      cut = string.indexOf('"', 1);
      contents = string.slice(1, cut);
      remdr = string.slice(cut + 1);
      result = {
        match: "yes",
        parse_object: ["<string>", contents],
        remainder: remdr
      };
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  ParseHelpers.prototype.look_for_integer = function(string) {
    var end, int, ref, ref1, result;
    if (ref = string[0], indexOf.call("0123456789", ref) >= 0) {
      if (ref1 = string[1], indexOf.call("0123456789", ref1) >= 0) {
        int = Number(string.slice(0, 2));
        end = string.slice(2);
      } else {
        int = Number(string[0]);
        end = string.slice(1);
      }
      result = {
        match: "yes",
        parse_object: ["<integer>", int],
        remainder: end
      };
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  return ParseHelpers;

})();

NumericExpressionParser = (function() {
  function NumericExpressionParser() {
    this.num_exp_chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "(", ")", "+", "-", "*", "/", "^"];
    this.delimiters = ["(", ")", "+", "-", "*", "/", "^"];
    this.symbols = ["<left>", "<right>", "<plus>", "<minus>", "<times>", "<divide>", "<power>"];
    this.keywords = ["RND", "INT"];
    this.tokens = ["<random>", "<integer>"];
  }

  NumericExpressionParser.prototype.numeric_parse = function(string) {
    var first, j, last, len1, po, po1, po2, result, split_string, tk;
    split_string = this.sub_split(string);
    if (split_string.is_split === "no") {
      return result = this.parse_substring(string);
    } else {
      first = this.numeric_parse(split_string.first);
      last = this.numeric_parse(split_string.last);
      if (first.match === "no" || last.match === "no") {
        return result = {
          match: "no"
        };
      } else {
        po1 = first.parse_object;
        po1.pop();
        po = po1;
        po.push(split_string.split_token);
        po2 = last.parse_object;
        po2.shift();
        for (j = 0, len1 = po2.length; j < len1; j++) {
          tk = po2[j];
          po.push(tk);
        }
        return result = {
          match: "yes",
          parse_object: po
        };
      }
    }
  };

  NumericExpressionParser.prototype.sub_split = function(string) {
    var first, i, is_split, j, key, kw, last, len1, ref;
    is_split = "no";
    key = "";
    ref = this.keywords;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      kw = ref[j];
      if (is_split === "no") {
        i = string.indexOf(kw);
        if (i >= 0) {
          is_split = "yes";
          key = kw;
          first = string.slice(0, i);
          last = string.slice(i + kw.length);
        }
      }
    }
    if (is_split === "no") {
      return {
        is_split: "no"
      };
    } else {
      return {
        is_split: "yes",
        split_token: this.get_token(key),
        first: first,
        last: last
      };
    }
  };

  NumericExpressionParser.prototype.get_token = function(key) {
    var i;
    i = this.keywords.indexOf(key);
    if (i < 0) {
      return null;
    } else {
      return this.tokens[i];
    }
  };

  NumericExpressionParser.prototype.parse_substring = function(string) {
    var bad_chars, j, len1, ok, po, result, tk, tokens, val;
    bad_chars = string.search(/[^A-Z0-9\.+\-*\/\^()]/);
    if (bad_chars === -1) {
      po = ["<numeric_expression>"];
      ok = "yes";
      tokens = this.tokenize(string);
      for (j = 0, len1 = tokens.length; j < len1; j++) {
        tk = tokens[j];
        if (indexOf.call(this.symbols, tk) >= 0) {
          po.push(tk);
        } else {
          val = this.numeric_value(tk);
          if (val[0] === "bad") {
            ok = "no";
          } else {
            po.push(val[0]);
            po.push(val[1]);
          }
        }
      }
      po.push("<num_exp_end>");
    } else {
      ok = "no";
    }
    if (ok === "yes") {
      result = {
        match: "yes",
        parse_object: po
      };
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  NumericExpressionParser.prototype.tokenize = function(string) {
    var buffer, ch, j, len1, tokens;
    tokens = [];
    buffer = "";
    for (j = 0, len1 = string.length; j < len1; j++) {
      ch = string[j];
      if (indexOf.call(this.delimiters, ch) >= 0) {
        if (buffer !== "") {
          tokens.push(buffer);
          buffer = "";
        }
        tokens.push(this.symbols[this.delimiters.indexOf(ch)]);
      } else {
        buffer = buffer + ch;
      }
    }
    if (buffer !== "") {
      tokens.push(buffer);
    }
    return tokens;
  };

  NumericExpressionParser.prototype.numeric_value = function(string) {
    var ch, j, len1, non_numerics, ref, ref1, val;
    val = [];
    if (ref = string[0], indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", ref) >= 0) {
      if ((string.length === 1) || (string.length === 2 && (ref1 = string[1], indexOf.call("0123456789", ref1) >= 0))) {
        val[0] = "<number_variable>";
        val[1] = string;
      } else {
        val = ["bad", "bad"];
      }
    } else {
      non_numerics = "none";
      for (j = 0, len1 = string.length; j < len1; j++) {
        ch = string[j];
        if (!(indexOf.call("0123456789", ch) >= 0)) {
          if (ch === ".") {
            if (non_numerics === "one_period") {
              non_numerics = "bad";
            }
            if (non_numerics === "none") {
              non_numerics = "one_period";
            }
          } else {
            non_numerics = "bad";
          }
        }
      }
      if (non_numerics !== "bad") {
        val[0] = "<numeric_literal>";
        val[1] = Number(string);
      } else {
        val = ["bad", "bad"];
      }
    }
    return val;
  };

  return NumericExpressionParser;

})();

StringExpressionParser = (function() {
  function StringExpressionParser() {}

  StringExpressionParser.prototype.string_value_parse = function(string) {
    var j, len1, ok, po, result, tk, tokens, val;
    po = ["<string_expression>"];
    ok = "yes";
    tokens = this.tokenize(string);
    for (j = 0, len1 = tokens.length; j < len1; j++) {
      tk = tokens[j];
      if (tk === "<plus>") {
        po.push("<plus>");
      } else {
        val = this.string_value(tk);
        if (val[0] === "bad") {
          ok = "no";
        } else {
          po.push(val[0]);
          po.push(val[1]);
        }
      }
    }
    po.push("<str_exp_end>");
    if (ok === "yes") {
      result = {
        match: "yes",
        parse_object: po
      };
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  StringExpressionParser.prototype.tokenize = function(string) {
    var buffer, ch, j, len1, tokens;
    tokens = [];
    buffer = "";
    for (j = 0, len1 = string.length; j < len1; j++) {
      ch = string[j];
      if (ch === "+") {
        if (buffer !== "") {
          tokens.push(buffer);
          buffer = "";
        }
        tokens.push("<plus>");
      } else {
        buffer = buffer + ch;
      }
    }
    if (buffer !== "") {
      tokens.push(buffer);
    }
    return tokens;
  };

  StringExpressionParser.prototype.string_value = function(string) {
    var ch, quote_check, ref, ref1, ref2, str_var, val;
    val = ["bad", "bad"];
    quote_check = (function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = string.length; j < len1; j++) {
        ch = string[j];
        if (ch === '"') {
          results.push(ch);
        }
      }
      return results;
    })();
    if (quote_check.length === 2 && string[0] === '"' && string[string.length - 1] === '"') {
      val[0] = "<string_literal>";
      val[1] = string.slice(1, -1);
    } else {
      str_var = "no";
      if ((ref = string.length, indexOf.call([2, 3], ref) >= 0) && string[0] === "$") {
        if (ref1 = string[1], indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", ref1) >= 0) {
          if (string.length === 2) {
            str_var = "yes";
          } else {
            if (ref2 = string[2], indexOf.call("0123456789", ref2) >= 0) {
              str_var = "yes";
            }
          }
        }
      }
      if (str_var === "yes") {
        val[0] = "<string_variable>";
        val[1] = string.slice(1);
      }
    }
    return val;
  };

  return StringExpressionParser;

})();

BooleanExpressionParser = (function() {
  function BooleanExpressionParser(parse_helpers) {
    this.helpers = parse_helpers;
  }

  BooleanExpressionParser.prototype.boolean_parse = function(string) {
    var j, k, len1, len2, match, num_exp, num_id, po, prep, ref, ref1, remainder, result, str_id, str_val, tk, tokens;
    prep = this.strip_remainder(string);
    string = prep.string;
    remainder = prep.remainder;
    po = ["<boolean_expression>"];
    tokens = this.split(string);
    if (tokens !== "<not_a_boolean_expression>") {
      match = "yes";
      num_id = this.helpers.look_for_numeric_identifier(tokens[0]);
      if (num_id.match === "yes") {
        num_exp = this.helpers.num_exp_parser.numeric_parse(tokens[2]);
        if (num_exp.match === "yes") {
          po = po.concat(num_id.parse_object);
          po.push(tokens[1]);
          ref = num_exp.parse_object;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            tk = ref[j];
            po.push(tk);
          }
        }
      } else {
        str_id = this.helpers.look_for_string_identifier(tokens[0]);
        if (str_id.match === "yes") {
          str_val = this.helpers.str_exp_parser.string_value_parse(tokens[2]);
          if (str_val.match !== "bad") {
            ref1 = str_id.parse_object;
            for (k = 0, len2 = ref1.length; k < len2; k++) {
              tk = ref1[k];
              po.push(tk);
            }
            po.push(tokens[1]);
            po = po.concat(str_val.parse_object);
          } else {
            match = "no";
          }
        } else {
          match = "no";
        }
      }
    } else {
      match = "no";
    }
    if (match === "yes") {
      po.push("<bool_exp_end>");
      result = {
        match: "yes",
        parse_object: po,
        remainder: remainder
      };
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  BooleanExpressionParser.prototype.strip_remainder = function(string) {
    var cut, q1, q2, result, sp;
    cut = 0;
    q1 = string.indexOf('"');
    q2 = string.lastIndexOf('"');
    if ((q1 > 0) && (q1 !== q2)) {
      cut = q2 + 1;
    } else {
      sp = string.indexOf(" ");
      if (sp > 0) {
        cut = sp;
      } else {
        cut = 0;
      }
    }
    if (cut > 0) {
      result = {
        string: string.slice(0, cut),
        remainder: string.slice(cut)
      };
    } else {
      result = {
        string: string,
        remainder: ""
      };
    }
    return result;
  };

  BooleanExpressionParser.prototype.split = function(string) {
    var cut, find, po, token;
    po = [];
    token = "";
    find = string.indexOf("<");
    if (find > 0) {
      if (string[find + 1] === ">") {
        token = "<not_equal>";
      } else {
        if (string[find + 1] === "=") {
          token = "<lesser_equal>";
        } else {
          token = "<lesser_than>";
        }
      }
    }
    if (token === "") {
      find = string.indexOf(">");
      if (find > 0) {
        if (string[find + 1] === "=") {
          token = "<greater_equal>";
        } else {
          token = "<greater_than>";
        }
      }
    }
    if (token === "") {
      find = string.indexOf("=");
      if (find > 0) {
        token = "<equals>";
      }
    }
    if (token.length > 0) {
      po[0] = string.slice(0, find);
      po[1] = token;
      if (token === "<not_equal>" || token === "<lesser_equal>" || token === "<greater_equal>") {
        cut = find + 2;
      } else {
        cut = find + 1;
      }
      po[2] = string.slice(cut);
    } else {
      po = "<not_a_boolean_expression>";
    }
    return po;
  };

  return BooleanExpressionParser;

})();

ProgramLineBuilder = (function() {
  function ProgramLineBuilder() {
    this.num_exp = new NumExpBuilder;
    this.str_exp = new StrExpBuilder;
    this.bool_exp = new BoolExpBuilder(this);
    this.max_line_number = 32767;
  }

  ProgramLineBuilder.prototype.format = function(parse_object, line_text) {
    var cmd, error, line, line_number;
    if (parse_object[0] === "<line_number>") {
      if (parse_object.length < 4) {
        line = this.build_line_removal(parse_object);
      } else {
        cmd = parse_object[3];
        switch (cmd) {
          case "<remark>":
            line = this.build_remark(parse_object);
            break;
          case "<number_variable>":
            line = this.build_numeric_assignment(parse_object);
            break;
          case "<string_variable>":
            line = this.build_string_assignment(parse_object);
            break;
          case "<goto>":
          case "<gosub>":
            line = this.build_cmd_with_dest(parse_object);
            break;
          case "<return>":
          case "<clear_screen>":
          case "<end>":
            line = this.build_simple_cmd(parse_object);
            break;
          case "<if>":
            line = this.build_if_cmd(parse_object);
            break;
          case "<input>":
            line = this.build_input_cmd(parse_object);
            break;
          case "<print>":
          case "<print_line>":
            line = this.build_print_cmd(parse_object);
            break;
          case "<tab>":
            line = this.build_tab_cmd(parse_object);
            break;
          default:
            error = true;
        }
      }
      line_number = parse_object[1];
      if (line_number > this.max_line_number) {
        error = true;
      }
      if (error) {
        line = {
          command: "<formatting_error>"
        };
      } else {
        line.line_no = parse_object[1];
        line.text = line_text;
      }
    } else {
      line = this.build_console_command(parse_object);
    }
    return line;
  };

  ProgramLineBuilder.prototype.build_console_command = function(parse_object) {
    var cmd;
    if (parse_object.length === 1) {
      cmd = parse_object[0];
      switch (cmd) {
        case "<clear_command>":
          return {
            command: "<clear_command>"
          };
        case "<run_command>":
          return {
            command: "<run_command>"
          };
        case "<info_command>":
          return {
            command: "<info_command>"
          };
        case "<list_command>":
          return {
            command: "<list_command>"
          };
        default:
          return {
            command: "<formatting_error>"
          };
      }
    } else {
      return {
        command: "<formatting_error>"
      };
    }
  };

  ProgramLineBuilder.prototype.build_line_removal = function() {
    return {
      command: "<remove_line>"
    };
  };

  ProgramLineBuilder.prototype.build_remark = function(parse_object) {
    return {
      command: "<remark>"
    };
  };

  ProgramLineBuilder.prototype.build_numeric_assignment = function(parse_object) {
    var line, nmx, stack;
    stack = parse_object.slice(6, +(parse_object.length - 1) + 1 || 9e9);
    nmx = this.num_exp.build_nxp(stack);
    if (nmx.malformed === "yes") {
      line = {
        command: "<formatting_error>"
      };
    } else {
      line = {
        command: "<numeric_assignment>",
        operand: parse_object[4],
        expression: nmx
      };
    }
    return line;
  };

  ProgramLineBuilder.prototype.build_string_assignment = function(parse_object) {
    var line, stack, str_exp;
    stack = parse_object.slice(6, +(parse_object.length - 1) + 1 || 9e9);
    str_exp = this.str_exp.build_str_exp(stack);
    line = {
      command: "<string_assignment>",
      operand: parse_object[4],
      expression: str_exp
    };
    return line;
  };

  ProgramLineBuilder.prototype.build_cmd_with_dest = function(parse_object) {
    return {
      command: parse_object[3],
      dest: parse_object[6]
    };
  };

  ProgramLineBuilder.prototype.build_simple_cmd = function(parse_object) {
    return {
      command: parse_object[3]
    };
  };

  ProgramLineBuilder.prototype.build_if_cmd = function(parse_object) {
    var bool_exp, line, stack;
    stack = parse_object.slice(5, +(parse_object.length - 6) + 1 || 9e9);
    bool_exp = this.bool_exp.build_bool_exp(stack);
    line = {
      command: "<if>",
      dest: parse_object.pop(),
      cond: bool_exp
    };
    return line;
  };

  ProgramLineBuilder.prototype.build_input_cmd = function(parse_object) {
    var cmd, line, op, prompt;
    if (parse_object.length === 10) {
      op = parse_object[9];
      prompt = parse_object[6];
      if (parse_object[8] === "<number_variable>") {
        cmd = "<input_numeric>";
      } else {
        cmd = "<input_string>";
      }
    } else {
      op = parse_object[6];
      prompt = "";
      if (parse_object[5] === "<number_variable>") {
        cmd = "<input_numeric>";
      } else {
        cmd = "<input_string>";
      }
    }
    line = {
      command: cmd,
      operand: op,
      prompt: prompt
    };
    return line;
  };

  ProgramLineBuilder.prototype.build_print_cmd = function(parse_object) {
    var cmd, line, stack, str_exp;
    if (parse_object.length === 4) {
      line = {
        command: parse_object[3],
        expression: [["<str>", ""]]
      };
    } else {
      if (parse_object[5] === "<number_variable>") {
        if (parse_object[3] === "<print_line>") {
          cmd = "<print_num_line>";
        } else {
          cmd = "<print_num>";
        }
        line = {
          command: cmd,
          name: parse_object[6]
        };
      } else {
        stack = parse_object.slice(5, +(parse_object.length - 1) + 1 || 9e9);
        str_exp = this.str_exp.build_str_exp(stack);
        line = {
          command: parse_object[3],
          expression: str_exp
        };
      }
    }
    return line;
  };

  ProgramLineBuilder.prototype.build_tab_cmd = function(parse_object) {
    var line;
    line = {};
    if (parse_object.length === 10) {
      line.command = "<tab_line_col>";
      line.line = parse_object[6];
      line.col = parse_object[9];
    } else {
      line.command = "<tab_col>";
      line.col = parse_object[6];
    }
    return line;
  };

  return ProgramLineBuilder;

})();

NumExpBuilder = (function() {
  function NumExpBuilder() {
    this.search_terms = [["<plus>", "<minus>"], ["<times>", "<divide>"], ["<power>"], ["<numeric_literal>", "<number_variable>"], ["<random>", "<integer>"]];
  }

  NumExpBuilder.prototype.build_nxp = function(stack) {
    var first, last, nxp;
    first = stack.shift();
    last = stack.pop();
    if (first === "<numeric_expression>" && last === "<num_exp_end>") {
      nxp = this.build_num_exp(stack);
    } else {
      nxp = {
        malformed: "yes"
      };
    }
    return nxp;
  };

  NumExpBuilder.prototype.build_num_exp = function(stack) {
    var nxp, split_stack;
    split_stack = this.split(stack);
    if (split_stack.malformed === "yes") {
      nxp = {
        malformed: "yes"
      };
    } else {
      switch (split_stack.exp) {
        case "<plus>":
        case "<minus>":
        case "<times>":
        case "<divide>":
        case "<power>":
          nxp = this.build_binary_expression(split_stack);
          break;
        case "<numeric_literal>":
          nxp = this.build_numeric_literal(split_stack);
          break;
        case "<number_variable>":
          nxp = this.build_number_variable(split_stack);
          break;
        case "<random>":
          nxp = this.build_random(split_stack);
          break;
        case "<integer>":
          nxp = this.build_integer_function(split_stack);
          break;
        default:
          nxp = {
            malformed: "yes"
          };
      }
    }
    return nxp;
  };

  NumExpBuilder.prototype.build_binary_expression = function(split_stack) {
    var left, result, right;
    result = {};
    left = this.build_nxp(split_stack.left);
    right = this.build_nxp(split_stack.right);
    if (right.malformed === "yes" || left.malformed === "yes") {
      result = {
        malformed: "yes"
      };
    } else {
      result = {
        exp: split_stack.exp,
        op1: left,
        op2: right
      };
    }
    return result;
  };

  NumExpBuilder.prototype.build_numeric_literal = function(split_stack) {
    var result;
    result = {};
    if (split_stack.right.length === 1) {
      result = {
        exp: "<num>",
        value: split_stack.right[0]
      };
    } else {
      result = {
        malformed: "yes"
      };
    }
    return result;
  };

  NumExpBuilder.prototype.build_number_variable = function(split_stack) {
    var result;
    result = {};
    if (split_stack.right.length === 1) {
      result = {
        exp: "<var>",
        name: split_stack.right[0]
      };
    } else {
      result = {
        malformed: "yes"
      };
    }
    return result;
  };

  NumExpBuilder.prototype.build_random = function(split_stack) {
    var result;
    result = {
      exp: "<random>"
    };
    return result;
  };

  NumExpBuilder.prototype.build_integer_function = function(split_stack) {
    var op, result;
    op = this.build_nxp(split_stack.right);
    if (op.malformed === "yes") {
      result = {
        malformed: "yes"
      };
    } else {
      result = {
        exp: "<integer>",
        op: op
      };
    }
    return result;
  };

  NumExpBuilder.prototype.split = function(stack) {
    var exp, find, index, j, k, left, len1, len2, level, ref, result, right, tt;
    stack = this.deparenthesize(stack);
    index = 999;
    ref = this.search_terms;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      level = ref[j];
      if (index === 999) {
        for (k = 0, len2 = level.length; k < len2; k++) {
          tt = level[k];
          find = stack.indexOf(tt);
          if (find >= 0 && find < index) {
            index = find;
          }
        }
        if (index < 999) {
          if (index === 0) {
            exp = stack[0];
            left = [];
            right = stack.slice(1);
            if (Array.isArray(right[0])) {
              right = right[0];
            }
            if (right.length > 1) {
              if (right[0] !== "<numeric_expression>") {
                right.unshift("<numeric_expression>");
                right.push("<num_exp_end>");
              }
            }
          } else {
            exp = stack[index];
            left = stack.slice(0, +(index - 1) + 1 || 9e9);
            right = stack.slice(index + 1);
            if (Array.isArray(left[0])) {
              left = left[0];
            }
            if (Array.isArray(right[0])) {
              right = right[0];
            }
            if (left[0] !== "<numeric_expression>") {
              left.unshift("<numeric_expression>");
              left.push("<num_exp_end>");
            }
            if (right[0] !== "<numeric_expression>") {
              right.unshift("<numeric_expression>");
              right.push("<num_exp_end>");
            }
          }
          result = {
            exp: exp,
            left: left,
            right: right
          };
        } else {
          result = {
            malformed: "yes"
          };
        }
      }
    }
    return result;
  };

  NumExpBuilder.prototype.deparenthesize = function(stack) {
    var i, j, k, left, len1, len2, nested_array, nesting, new_stack, ok, ref, ref1, right, tk;
    ok = "yes";
    nesting = 0;
    i = -1;
    while (stack.indexOf("<left>") >= 0 && ok === "yes") {
      i = i + 1;
      if (stack[i] === "<left>") {
        left = i;
        nesting = nesting + 1;
      }
      if (stack[i] === "<right>") {
        if (nesting === 0) {
          ok = "no";
        } else {
          right = i;
          new_stack = [];
          if (left > 0) {
            ref = stack.slice(0, +(left - 1) + 1 || 9e9);
            for (j = 0, len1 = ref.length; j < len1; j++) {
              tk = ref[j];
              new_stack.push(tk);
            }
          }
          nested_array = stack.slice(left + 1, +(right - 1) + 1 || 9e9);
          new_stack.push(nested_array);
          ref1 = stack.slice(right + 1, +(stack.length - 1) + 1 || 9e9);
          for (k = 0, len2 = ref1.length; k < len2; k++) {
            tk = ref1[k];
            new_stack.push(tk);
          }
          stack = new_stack;
          nesting = 0;
          i = -1;
          if (stack.length === 1) {
            stack = stack[0];
          }
        }
      }
    }
    if (ok === "bad") {
      return {
        malformed: "yes"
      };
    } else {
      return stack;
    }
  };

  return NumExpBuilder;

})();

StrExpBuilder = (function() {
  function StrExpBuilder() {}

  StrExpBuilder.prototype.build_str_exp = function(stack) {
    var j, parts, ref, t, tk;
    parts = [];
    for (t = j = 1, ref = stack.length - 3; j <= ref; t = j += 3) {
      if (stack[t] === "<string_variable>") {
        tk = "<var>";
      } else {
        tk = "<str>";
      }
      parts.push([tk, stack[t + 1]]);
    }
    return parts;
  };

  return StrExpBuilder;

})();

BoolExpBuilder = (function() {
  function BoolExpBuilder(line_builder) {
    this.line_builder = line_builder;
    this.num_exp = this.line_builder.num_exp;
    this.str_exp = this.line_builder.str_exp;
  }

  BoolExpBuilder.prototype.build_bool_exp = function(stack) {
    var bool, bx_stack, tag, tag_end, type;
    if (stack[1] === "<number_variable>") {
      type = "num";
    } else {
      type = "str";
    }
    tag_end = stack[3].slice(1);
    tag = "<" + type + "_" + tag_end;
    bool = {
      exp: tag,
      "var": stack[2]
    };
    bx_stack = stack.slice(4, +(stack.length - 2) + 1 || 9e9);
    if (type === "num") {
      bool.num_exp = this.num_exp.build_nxp(bx_stack);
    } else {
      bool.str_exp = this.str_exp.build_str_exp(bx_stack);
    }
    return bool;
  };

  return BoolExpBuilder;

})();

InterpreterHelpers = (function() {
  function InterpreterHelpers(prog_command_runner) {
    this.statement_runner = prog_command_runner;
    this.keys = this.statement_runner.keys;
    this.num_vars = new NumericVariableRegister;
    this.str_vars = new StringVariableRegister;
    this.num_eval = new NumericExpressionEvaluator(this);
    this.num_form = new NumericStringFormatter;
    this.str_eval = new StringExpressionConcatenator(this);
    this.bx_eval = new BooleanExpressionEvaluator(this);
    this.input = new UserInputHelper(this);
  }

  return InterpreterHelpers;

})();

VariableRegister = (function() {
  function VariableRegister() {
    this.vars = {};
  }

  VariableRegister.prototype.add_var = function(name) {
    return this.vars[name] = null;
  };

  VariableRegister.prototype.defined = function(name) {
    if (this.vars.hasOwnProperty(name)) {
      return "yes";
    } else {
      return "no";
    }
  };

  VariableRegister.prototype.set = function(name, value) {
    if (this.defined(name) === "no") {
      this.add_var(name);
    }
    return this.vars[name] = value;
  };

  VariableRegister.prototype.get = function(name) {
    if (this.defined(name) === "no") {
      this.add_var(name);
    }
    return this.vars[name];
  };

  return VariableRegister;

})();

NumericVariableRegister = (function(superClass) {
  extend(NumericVariableRegister, superClass);

  function NumericVariableRegister() {
    return NumericVariableRegister.__super__.constructor.apply(this, arguments);
  }

  NumericVariableRegister.prototype.add_var = function(name) {
    return this.vars[name] = 0;
  };

  return NumericVariableRegister;

})(VariableRegister);

StringVariableRegister = (function(superClass) {
  extend(StringVariableRegister, superClass);

  function StringVariableRegister() {
    return StringVariableRegister.__super__.constructor.apply(this, arguments);
  }

  StringVariableRegister.prototype.add_var = function(name) {
    return this.vars[name] = "";
  };

  return StringVariableRegister;

})(VariableRegister);

NumericExpressionEvaluator = (function() {
  function NumericExpressionEvaluator(helpers) {
    this.vars = helpers.num_vars;
  }

  NumericExpressionEvaluator.prototype.val = function(num_exp) {
    var value;
    switch (num_exp.exp) {
      case "<num>":
        value = this.num_lit_eval(num_exp);
        break;
      case "<var>":
        value = this.num_var_eval(num_exp);
        break;
      case "<plus>":
      case "<minus>":
      case "<times>":
      case "<divide>":
      case "<power>":
        value = this.binary_op_eval(num_exp);
        break;
      case "<random>":
        value = this.random_eval();
        break;
      case "<integer>":
        value = this.integer_eval(num_exp);
        break;
      default:
        value = "error";
    }
    return value;
  };

  NumericExpressionEvaluator.prototype.num_lit_eval = function(num_exp) {
    return num_exp.value;
  };

  NumericExpressionEvaluator.prototype.num_var_eval = function(num_exp) {
    return this.vars.get(num_exp.name);
  };

  NumericExpressionEvaluator.prototype.random_eval = function() {
    return Math.random();
  };

  NumericExpressionEvaluator.prototype.integer_eval = function(num_exp) {
    return Math.floor(this.val(num_exp.op));
  };

  NumericExpressionEvaluator.prototype.binary_op_eval = function(num_exp) {
    var a, b, exp, value;
    a = this.val(num_exp.op1);
    b = this.val(num_exp.op2);
    exp = num_exp.exp;
    switch (exp) {
      case "<plus>":
        return value = a + b;
      case "<minus>":
        return value = a - b;
      case "<times>":
        return value = a * b;
      case "<divide>":
        return value = a / b;
      case "<power>":
        return value = Math.pow(a, b);
      default:
        return value = "error";
    }
  };

  return NumericExpressionEvaluator;

})();

NumericStringFormatter = (function() {
  function NumericStringFormatter() {
    this.digits = 8;
  }

  NumericStringFormatter.prototype.num_to_str = function(num) {
    var chars, str;
    str = num.toString();
    if (str.indexOf(".") > 0) {
      chars = this.digits + 1;
    } else {
      chars = this.digits;
    }
    if (str.length > chars) {
      str = str.slice(0, +(chars - 1) + 1 || 9e9);
    }
    return str;
  };

  return NumericStringFormatter;

})();

StringExpressionConcatenator = (function() {
  function StringExpressionConcatenator(helpers) {
    this.vars = helpers.str_vars;
  }

  StringExpressionConcatenator.prototype.val = function(str_exp) {
    var j, len1, string, term;
    string = "";
    for (j = 0, len1 = str_exp.length; j < len1; j++) {
      term = str_exp[j];
      if (term[0] === "<str>") {
        string = string.concat(term[1]);
      }
      if (term[0] === "<var>") {
        string = string.concat(this.vars.get(term[1]));
      }
    }
    return string;
  };

  StringExpressionConcatenator.prototype.str_var_eval = function(term) {
    return this.vars.get(term[0]);
  };

  return StringExpressionConcatenator;

})();

BooleanExpressionEvaluator = (function() {
  function BooleanExpressionEvaluator(helpers) {
    this.str_vars = helpers.str_vars;
    this.num_vars = helpers.num_vars;
    this.str_eval = helpers.str_eval;
    this.num_eval = helpers.num_eval;
    this.truth_table = {
      "<num_equals>": [false, true, false],
      "<num_not_equal>": [true, false, true],
      "<num_lesser_than>": [true, false, false],
      "<num_lesser_equal>": [true, true, false],
      "<num_greater_than>": [false, false, true],
      "<num_greater_equal>": [false, true, true],
      "<str_equals>": [false, true],
      "<str_not_equal>": [true, false]
    };
  }

  BooleanExpressionEvaluator.prototype.val = function(bx) {
    var comp, ref;
    if ((ref = bx.exp) === "<str_equals>" || ref === "<str_not_equal>") {
      comp = this.str_compare(this.str_vars.get(bx["var"]), this.str_eval.val(bx.str_exp));
    } else {
      comp = this.num_compare(this.num_vars.get(bx["var"]), this.num_eval.val(bx.num_exp));
    }
    return this.truth_table[bx.exp][comp];
  };

  BooleanExpressionEvaluator.prototype.num_compare = function(x1, x2) {
    if (x1 < x2) {
      return 0;
    }
    if (x1 === x2) {
      return 1;
    }
    if (x1 > x2) {
      return 2;
    }
  };

  BooleanExpressionEvaluator.prototype.str_compare = function(s1, s2) {
    if (s1 === s2) {
      return 1;
    } else {
      return 0;
    }
  };

  return BooleanExpressionEvaluator;

})();

UserInputHelper = (function() {
  function UserInputHelper(helpers) {
    this.helpers = helpers;
    this.str_vars = this.helpers.str_vars;
    this.num_vars = this.helpers.num_vars;
    this.keys = this.helpers.keys;
    this.bconsole = this.keys.bconsole;
    this.line_object = {};
  }

  UserInputHelper.prototype.set_up_input = function(line_object) {
    var prompt;
    this.line_object = line_object;
    prompt = this.line_object.prompt + "? ";
    this.keys.set_input_mode();
    return this.bconsole.print(prompt);
  };

  UserInputHelper.prototype.process_user_input = function(str) {
    var number, result;
    if (this.line_object.command === "<input_numeric>") {
      number = Number(str);
      if (isFinite(number)) {
        this.num_vars.set(this.line_object.operand, number);
        result = "<numeric_input:success>";
      } else {
        result = "<numeric_input:fail>";
      }
    } else {
      this.str_vars.set(this.line_object.operand, str);
      result = "<string_input:success>";
    }
    return result;
  };

  return UserInputHelper;

})();

BasicConsole = (function() {
  function BasicConsole(key_talker) {
    this.console_height = 23;
    this.console_width = 80;
    this.key_talker = key_talker;
    this.buffer = new ConsoleLineBuffer(this);
    this.keys = new KeyHelper;
    this.info = new InfoAndHelp;
    this.sprites = new Image();
    this.sprites.onload = (function(_this) {
      return function() {
        console.log("* * * * sprites onload * * * *");
        return _this.display_info("menu");
      };
    })(this);
    this.sprites.src = 'app/characters.png';
    this.canvas = document.getElementById('gb80-console');
    this.context = this.canvas.getContext('2d');
    this.line = 0;
    this.scroll = [];
    this.lines = [];
    this.column = 0;
    this.draw_cursor(0, 1);
  }

  BasicConsole.prototype.enter_line = function() {
    var line;
    line = this.buffer.chars;
    if (line.length > 0) {
      this.draw_blank_char(this.line, this.column + 1);
      this.scroll_line(line);
      this.buffer.clear();
    }
    return line;
  };

  BasicConsole.prototype.scroll_line = function(string) {
    this.column = 0;
    this.scroll.push(string);
    if (this.scroll.length >= this.console_height) {
      this.scroll.shift();
      this.redraw_lines();
      this.column = 0;
    } else {
      this.line = this.line + 1;
    }
    return this.draw_cursor(this.line, 1);
  };

  BasicConsole.prototype.redraw_lines = function() {
    var j, len1, ref, str;
    this.clear_screen();
    this.line = 0;
    ref = this.scroll;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      str = ref[j];
      this.column = 0;
      this.print(str);
      this.line = this.line + 1;
    }
    return this.draw_cursor(this.line, 1);
  };

  BasicConsole.prototype.print = function(string) {
    var ch, j, len1;
    this.draw_blank_char(this.line, 1);
    for (j = 0, len1 = string.length; j < len1; j++) {
      ch = string[j];
      this.column = this.column + 1;
      if (this.column <= this.console_width) {
        this.ch_ln_col(ch, this.line, this.column);
      }
    }
    this.line_text = string;
    return this.buffer.clear();
  };

  BasicConsole.prototype.println = function(string) {
    this.print(string);
    return this.scroll_line(string);
  };

  BasicConsole.prototype.print_program = function(lines) {
    var j, len1, line, page;
    page = lines.splice(0, this.console_height - 2);
    for (j = 0, len1 = page.length; j < len1; j++) {
      line = page[j];
      this.println(line.text);
    }
    if (lines.length > 0) {
      return this.pause_scroll(lines);
    }
  };

  BasicConsole.prototype.pause_scroll = function(lines) {
    this.lines = lines;
    return this.key_talker.set_scroll_pause();
  };

  BasicConsole.prototype.resume_scroll = function() {
    return this.print_program(this.lines);
  };

  BasicConsole.prototype.println_ln = function(line_no, string) {
    this.line = line_no;
    return this.print(string);
  };

  BasicConsole.prototype.ch = function(ch) {
    this.column = this.column + 1;
    this.draw_blank_char(this.line, this.column);
    this.buffer.add(ch);
    if (this.column <= this.console_width) {
      this.ch_ln_col(ch, this.line, this.column);
    }
    return this.draw_cursor(this.line, this.column + 1);
  };

  BasicConsole.prototype.ch_ln_col = function(ch, line, column) {
    var sprite;
    this.line_text = ch + " [" + line + "," + column + "]";
    if (ch !== " ") {
      sprite = this.keys.sprite_xy(ch);
      return this.context.drawImage(this.sprites, sprite[0], sprite[1], 11, 18, 3 + column * 11, 16 + line * 18, 11, 18);
    }
  };

  BasicConsole.prototype.draw_blank_char = function(line, column) {
    return this.context.clearRect(3 + column * 11, 16 + line * 18, 11, 18);
  };

  BasicConsole.prototype.draw_cursor = function(line, column) {
    var x;
    if (this.keys.monitor_color === "green") {
      x = 255;
    } else {
      x = 110;
    }
    return this.context.drawImage(this.sprites, x, 90, 11, 18, 3 + column * 11, 16 + line * 18, 11, 18);
  };

  BasicConsole.prototype.backspace = function() {
    if (this.column > 0) {
      this.draw_blank_char(this.line, this.column + 1);
      this.draw_blank_char(this.line, this.column);
      this.draw_cursor(this.line, this.column);
      this.buffer.trim();
      return this.column = this.column - 1;
    }
  };

  BasicConsole.prototype.error_message = function() {
    return this.println("SYNTAX ERROR");
  };

  BasicConsole.prototype.display_info = function(key) {
    var j, len1, msg_line, ref, results;
    ref = this.info.message[key];
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      msg_line = ref[j];
      results.push(this.println(msg_line));
    }
    return results;
  };

  BasicConsole.prototype.clear_screen = function() {
    return this.context.clearRect(0, 0, 910, 440);
  };

  BasicConsole.prototype.clear_all = function() {
    this.clear_screen();
    this.scroll = [];
    return this.line_text = "";
  };

  BasicConsole.prototype.monitor_amber = function() {
    this.keys.monitor_color = "amber";
    return this.redraw_lines();
  };

  BasicConsole.prototype.monitor_green = function() {
    this.keys.monitor_color = "green";
    return this.redraw_lines();
  };

  return BasicConsole;

})();

ConsoleLineBuffer = (function() {
  function ConsoleLineBuffer(bconsole) {
    this.bconsole = bconsole;
    this.chars = "";
  }

  ConsoleLineBuffer.prototype.add = function(ch) {
    return this.chars = this.chars + ch;
  };

  ConsoleLineBuffer.prototype.trim = function() {
    if (this.chars.length > 0) {
      return this.chars = this.chars.slice(0, this.chars.length - 1);
    }
  };

  ConsoleLineBuffer.prototype.clear = function() {
    return this.chars = "";
  };

  ConsoleLineBuffer.prototype.print = function() {
    this.bconsole.println(this.chars);
    return this.chars = "";
  };

  return ConsoleLineBuffer;

})();

ProgramLineListing = (function() {
  function ProgramLineListing() {
    this.lines = {};
  }

  ProgramLineListing.prototype.clear = function() {
    return this.lines = {};
  };

  ProgramLineListing.prototype.get_line = function(line_no) {
    return this.lines[line_no.toString()];
  };

  ProgramLineListing.prototype.get_program_objects = function() {
    return this.lines;
  };

  ProgramLineListing.prototype.add_or_change = function(line_object) {
    var ln;
    if (line_object.command === "<remove_line>") {
      return this.remove(line_object.line_no);
    } else {
      ln = line_object.line_no;
      return this.lines[ln.toString()] = line_object;
    }
  };

  ProgramLineListing.prototype.remove = function(line_no) {
    return delete this.lines[line_no.toString()];
  };

  ProgramLineListing.prototype.list = function() {
    var j, len1, line_numbers, list, ln;
    list = [];
    line_numbers = this.lines_sort();
    for (j = 0, len1 = line_numbers.length; j < len1; j++) {
      ln = line_numbers[j];
      list.push(this.lines[ln]);
    }
    return list;
  };

  ProgramLineListing.prototype.lines_sort = function() {
    var line, line_numbers, ln_key, ref;
    line_numbers = [];
    ref = this.lines;
    for (ln_key in ref) {
      line = ref[ln_key];
      line_numbers.push(line.line_no);
    }
    line_numbers.sort(function(a, b) {
      return a - b;
    });
    return line_numbers;
  };

  return ProgramLineListing;

})();

KeyHelper = (function() {
  function KeyHelper() {
    this.monitor_color = "green";
    this.code = [173, 61, 59, 189, 187, 186, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 107, 109, 106, 111, 110, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 188, 190, 191, 192, 219, 221, 222];
    this.keys = [["-", "_"], ["=", "+"], [";", ":"], ["-", "_"], ["=", "+"], [";", ":"], ["0", ")"], ["1", "!"], ["2", "@"], ["3", "#"], ["4", "$"], ["5", "%"], ["6", "^"], ["7", "&"], ["8", "*"], ["9", "("], ["0", "0"], ["1", "1"], ["2", "2"], ["3", "3"], ["4", "4"], ["5", "5"], ["6", "6"], ["7", "7"], ["8", "8"], ["9", "9"], ["+", "+"], ["-", "-"], ["*", "*"], ["/", "/"], [".", "."], ["A", "A"], ["B", "B"], ["C", "C"], ["D", "D"], ["E", "E"], ["F", "F"], ["G", "G"], ["H", "H"], ["I", "I"], ["J", "J"], ["K", "K"], ["L", "L"], ["M", "M"], ["N", "N"], ["O", "O"], ["P", "P"], ["Q", "Q"], ["R", "R"], ["S", "S"], ["T", "T"], ["U", "U"], ["V", "V"], ["W", "W"], ["X", "X"], ["Y", "Y"], ["Z", "Z"], [",", "<"], [".", ">"], ["/", "?"], ["`", "~"], ["[", "{"], ["]", "}"], ["'", '"']];
    this.chars = ["!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "^", "_", "`", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "{", "|", "}", "~"];
    this.xy = [[99, 72], [33, 72], [33, 90], [77, 72], [88, 72], [44, 90], [22, 72], [66, 54], [77, 54], [33, 54], [11, 54], [55, 72], [22, 54], [44, 72], [44, 54], [0, 36], [11, 36], [22, 36], [33, 36], [44, 36], [55, 36], [66, 36], [77, 36], [88, 36], [99, 36], [0, 72], [11, 72], [88, 54], [0, 54], [99, 54], [66, 72], [22, 90], [55, 54], [55, 90], [0, 90], [0, 0], [11, 0], [22, 0], [33, 0], [44, 0], [55, 0], [66, 0], [77, 0], [88, 0], [99, 0], [110, 0], [121, 0], [132, 0], [0, 18], [11, 18], [22, 18], [33, 18], [44, 18], [55, 18], [66, 18], [77, 18], [88, 18], [99, 18], [110, 18], [121, 18], [132, 18], [66, 90], [99, 90], [77, 90], [11, 90]];
  }

  KeyHelper.prototype.char = function(n, shift_status) {
    var ch, i;
    if (indexOf.call(this.code, n) >= 0) {
      i = this.code.indexOf(n);
      if (shift_status === "<shift>") {
        ch = this.keys[i][1];
      } else {
        ch = this.keys[i][0];
      }
    } else {
      if (n === 32) {
        ch = " ";
      } else {
        ch = null;
      }
    }
    return ch;
  };

  KeyHelper.prototype.sprite_xy = function(ch) {
    var i, xx, yy;
    if (indexOf.call(this.chars, ch) >= 0) {
      i = this.chars.indexOf(ch);
      xx = this.xy[i][0];
      yy = this.xy[i][1];
      if (this.monitor_color === "green") {
        xx = xx + 145;
      }
      return [xx, yy];
    } else {
      return [121, 54];
    }
  };

  return KeyHelper;

})();

InfoAndHelp = (function() {
  function InfoAndHelp() {
    this.message = {};
    this.message["menu"] = ["EXAMPLE PROGRAM LINES:", "100 X=333", "120 S=X*1000", "180 IF M>20 THEN 400", "210 GOTO 800", " ", "ADD LINES TO THE PROGRAM BY TYPING A LINE NUMBER, FOLLOWED BY", "THE REST OF THE LINE, THEN HIT <ENTER>.", " ", 'TYPE "RUN" TO RUN YOUR PROGRAM.', 'TYPE "LIST" TO SEE A LISTING OF ALL PROGRAM LINES.', "TYPE THE LINE NUMBER, THEN <ENTER>, TO REMOVE A PROGRAM LINE.", 'TYPE "CLEAR" TO REMOVE ALL PROGRAM LINES.', 'TYPE "INFO" TO PRINT THIS HELP PAGES.', " ", "GRANDPA BASIC 1980", "HTTP://GB80-TOQUIMA.RHCLOUD.COM", "HAVE FUN!", " "];
    this.message["example"] = ["HERE'S AN EXAMPLE PROGRAM:", "10 REM GRANDPA BASIC 1980 - SAMPLE PROGRAM 1", "100 X=17", "110 Y=13", "120 S=(X-Y)/2", "180 IF S=2 THEN 400", '200 $Z="S DOES NOT EQUAL 2"', "210 GOTO 800", '400 $Z="S EQUALS 2"', "410 GOTO 800", "800 PRINT $Z", '900 PRINT "WE ARE DONE"', "999 END"];
  }

  return InfoAndHelp;

})();

keyevent = function(e) {
  var key_code;
  if (this.disable_key_defaults) {
    e.preventDefault();
  }
  key_code = e.keyCode;
  return this.app.handle(key_code);
};

keyup = function(e) {
  var key_code;
  key_code = e.keyCode;
  return this.app.handle_keyup(key_code);
};

start = function() {
  this.canvas = document.getElementById("gb80-console");
  this.canvas.setAttribute('tabindex', '0');
  this.canvas.focus();
  this.disable_key_defaults = true;
  this.app = new KeyTalker;
  if (monitor_color === "amber") {
    return this.monitor_amber();
  } else {
    return this.monitor_green();
  }
};

monitor_green = function() {
  return this.app.monitor_green();
};

monitor_amber = function() {
  return this.app.monitor_amber();
};

window.onload = start;
